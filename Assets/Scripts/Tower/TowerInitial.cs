using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using static GlobalData;

//这个脚本用来初始化一个塔
//关于塔的特殊效果统统放在子弹上！！！！（暂定）
public class TowerInitial : MonoBehaviour
{
    //一个塔对应一个坑
    [HideInInspector]
    public Transform hole;

    //子弹预制体
    [Header("子弹预制件")]
    public GameObject bulletPrefab;

    //攻击范围半径
    [Header("索敌范围")]
    [Range(0, 20)]public float attackRange = 2f;

    //子弹间隔时间
    [Header("攻击间隔时间")]
    [Range(0, 2)]public float shootTime = 0.5f;

    //List<Enemy> enemies = new List<Enemy>();

    //public Enemy oneEnemy;

    //用来计算间隔时间
    float timeSinceLastShot = 0f;

    void Awake()
    {
        //调整物体至中央
        Adjust();
    }
    void Update()
    {
        //计算时间间隔.累加时间
        timeSinceLastShot += Time.deltaTime;
        if (timeSinceLastShot < shootTime) { 
            return; //如果时间间隔小于1秒，则不执行攻击逻辑
        }

        //Enemy closestEnemy = FindClosestEnemy(attackRange);
        Enemy closestEnemy = FindClosestToFinishEnemy(attackRange);

        if (closestEnemy != null)
        {
            Shoot(closestEnemy.GetGameObject());
        }

        timeSinceLastShot = 0f; //重置时间间隔
    }

    void Shoot(GameObject enemy)
    {
        //子弹在塔上方1.5米的位置发射
        Vector3 offset = new Vector3(0, 1f, 0);
        //实例化子弹
        GameObject bullet = Instantiate(bulletPrefab, transform.position + offset, Quaternion.identity);
        //需要锚定子弹的目标，获取子弹的行为脚本
        Bullet bulletScript = bullet.GetComponent<Bullet>();
        bulletScript.SetTarget(enemy);
    }

    //定位攻击半径内最近的敌人
    private Enemy FindClosestEnemy(float ShootingDistance)
    {
        Enemy closestEnemy = null;
        float closestDistance = Mathf.Infinity;//初始最近距离为无穷大
        //遍历列表中的所有敌人
        foreach (Enemy enemy in GlobalData.globalEnemies)
        {
            //跳过不需要攻击的敌人
            if (enemy.NoMoreShotsNeeded())
            {
                continue;
            }
            float distance = Vector2.Distance(transform.position, enemy.GetGameObject().transform.position);

            //筛选掉超过攻击范围的敌人，重新计算最近的敌人
            if (distance < closestDistance && distance < ShootingDistance)
            {
                closestDistance = distance;
                closestEnemy = enemy;
            }
        }
        return closestEnemy;
    }

    //定位攻击半径内离终点最近的敌人
    Enemy FindClosestToFinishEnemy(float ShootingDistance)
    {
        Enemy closestEnemy = null;
        float longestSurvivalTime = 0;//生存时间为0
        //遍历列表中的所有敌人
        foreach (Enemy enemy in GlobalData.globalEnemies)
        {
            //跳过不需要攻击的敌人
            if (enemy.NoMoreShotsNeeded())
            {
                continue;
            }
            //筛选掉超过攻击范围的敌人
            float distance = Vector2.Distance(transform.position, enemy.GetGameObject().transform.position);
            if (distance < ShootingDistance)
            {
                //
                //获取离终点最近的敌人，目前思路：敌人生成后，存活时间最长的就是离终点最近的
                //
                float survivalTime = enemy.GetComponent<Move>().survivalTime;
                if (survivalTime > longestSurvivalTime)
                {
                    longestSurvivalTime = survivalTime;
                    closestEnemy = enemy;
                }
            }
        }
        return closestEnemy;
    }

    //设置对应坑
    public void SetHole(Transform hole)
    {
        this.hole = hole;
    }

    //在编辑模式下显示Gizmo
    void OnDrawGizmos()
    {
        // 设置Gizmo颜色
        Gizmos.color = Color.red;
        // 绘制无填充圆圈
        Gizmos.DrawWireSphere(transform.position, attackRange);
    }
    public void Adjust()
    {
        //所有点的公式
        float widthStart = -7.5f;
        float widthEnd = 7.5f;
        float heightStart = -3.5f;
        float heightEnd = 4.5f;
        //调整物体的位置
        for (float x = widthStart; x <= widthEnd; x += 1.0f)
        {
            for (float y = heightStart; y <= heightEnd; y += 1.0f)
            {
                if (Mathf.Abs(transform.position.x - x) <= 0.5f && Mathf.Abs(transform.position.y - y) <= 0.5f)
                {
                    transform.position = new Vector3(x, y, 0f);
                    break;
                }
            }
        }
    }

    public void Remove()
    {
        //这里增加货币的回收方法

        //
        Destroy(gameObject);
    }
}
